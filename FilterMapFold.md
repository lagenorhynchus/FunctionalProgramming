## ■ filter
リストの1要素を受け取り真偽値を返す関数(述語)を渡すことにより、条件を満たす要素を抽出したリストを得ることができる。

利用例) 1～10のうち、偶数を取り出す

#### Haskell
```haskell
-- ラムダ式
filter (\x -> x `mod` 2 == 0) [1..10]

-- 関数even
filter even [1..10]

-- リスト内包表記による同等の処理
[x | x -> [1..10], x `mod` 2 == 0]
```

#### Clojure
```clojure
;; ラムダ式
(filter (fn [x] (= (mod x 2) 0)) (range 1 11))

;; ラムダ式のリーダマクロ
(filter #(= (mod % 2) 0) (range 1 11))

;; 関数even?
(filter even? (range 1 11))

;; リスト内包表記による同等の処理
(for [x (range 1 11) :when (= (mod x 2) 0)] x)
```

## ■ map
リストの1要素を受け取り変換後の値を返す関数を渡すことにより、全要素が変換されたリストを得ることができる。

利用例) 1～10をそれぞれ2乗する

#### Haskell
```haskell
-- ラムダ式
map (\x -> x ^ 2) [1..10]

-- 演算子の部分適用(セクション)
map (^ 2) [1..10]

-- リスト内包表記による同等の処理
[x ^ 2 | x <- [1..10]]
```

#### Clojure
```clojure
;; ラムダ式
(map (fn [x] (expt x 2)) (range 1 11))

;; ラムダ式のリーダマクロ
(map #(expt % 2) (range 1 11))

;; リスト内包表記による同等の処理
(for [x (range 1 11)] (expt x 2))
```

## ■ fold
リストの2要素を受け取り処理後の値を返す関数と初期値を渡すことにより、初期値とリストの各要素に対して処理した結果を得ることができる。
処理を左から適用するfoldlと右から適用するfoldrがある。

利用例) 1～10の積を計算する

#### Haskell
```haskell
-- ラムダ式
foldl' (\x y -> x * y) 1 [1..10]

-- 演算子の部分適用(セクション)
foldl' (*) 1 [1..10]

-- 関数productによる同等の処理
product [1..10]
```

#### Clojure
```clojure
;; ラムダ式
(reduce (fn [x y] (* x y)) 1 (range 1 11))

;; ラムダ式のリーダマクロ
(reduce #(* %1 %2) 1 (range 1 11))

;; 関数*
(reduce * 1 (range 1 11))

;; 関数applyを利用した同等の処理
(apply * (range 1 11))
```
